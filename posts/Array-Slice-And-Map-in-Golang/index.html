<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Array Slice And Map In Golang" /><meta property="og:locale" content="en" /><meta name="description" content="Array Array Internals and fundamentals An array in Go is a fixed-length data type that contains a contiguous block of elements of the same type. Arrays are valuable data structures because the memory is allocated sequentially. Having memory in a contiguous form can help to keep the memory you use stay loaded within CPU caches longer. An array is a value in Go. This means you can use it in an assignment operation. The variable name denotes the entire array and, therefore, an array can be assigned to other arrays of the same type. When an array is initialized in Go, each individual element that belongs to the array is initialized to its zero value. Declaring and Initializing Declare an integer array of five elements var array [5]int Array literals allow you to declare the number of elements you need and specify values for those elements Declaring and Initialize an array using an array literal array := [5]int{10, 20, 30, 40, 50} Declaring and Initialize an array with Go calculating size array := [...]int{10, 20, 30, 40, 50} Declaring an array initializing specific elements array := [5]int{1: 10, 2: 20} Declaring two-dimensional arrays var array [4][2]int Passing arrays between functions Passing an array between functions can be an expensive operation in terms of memory and performance. When your variable is an array, this means the entire array, regardless of its size, is copied and passed to the function. Slice Slice internals and fundamentals Slices are built around the concept of dynamic arrays that can grow and shrink They’re three field data structures that contain the metadata. The three fields are a pointer to the underlying array, the length or the number of elements the slice has access to, and the capacity or the number of elements the slice has available for growth. Remember, if you specify a value inside the [ ] operator, you’re creating an array. If you don’t specify a value, you’re creating a slice. Create an array of three integers. array := [3]int{10, 20, 30} Create a slice of integers with a length and capacity of three. slice := []int{10, 20, 30} Creating and Initializing When you use make, one option you have is to specify the length of the slice. Declaring a slice of strings by length slice := make([]string, 5) Declaring a slice of integers by length and capacity slice := make([]int, 3, 5) Contains a length of 3 and has a capacity of 5 elements. Trying to create a slice with a capacity that’s smaller than the length is not allowed Declaring a slice with a slice literal slice := []string{&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;} NIL and empty slices Declaring an nil slice. var slice []int A nil slice is created by declaring a slice without any initialization. Declaring an empty slice slice := make([]int, 0) slice := []int{} NIL useful when you want to represent a slice that doesn’t exist, such as when an exception occurs in a function that returns a slice. Empty slices are useful when you want to represent an empty collection, such as when a database query returns zero results . Regardless of whether you’re using a nil slice or an empty slice, the built-in functions append, len, and cap work the same. Working with slices Slices are called such because you can slice a portion of the underlying array to create a new slice. 1 2 slice := []int{10, 20, 30, 40, 50} newSlice := slice[1:3] Changes made to the shared section of the underlying array by one slice can be seen by the other slice. Calculating Length and Capacity of Slice For slice[i:j:k] or [2:3:4] Length: j - i or 3 - 2 = 1 Capacity: k - i or 4 - 2 = 2 To use append, you need a source slice and a value that is to be appended. When your append call returns, it provides you a new slice with the changes.The append function will always increase the length of the new slice. 1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { slice := []int{10,20,30,40,50} newSlice := slice[1:3] fmt.Println(slice) fmt.Println(newSlice) newSlice =append(newSlice,60) fmt.Println(slice) fmt.Println(newSlice) } [10 20 30 40 50] [20 30] [10 20 30 60 50] [20 30 60] Because there was available capacity in the underlying array for newSlice, the append operation incorporated the available element into the slice’s length and assigned the value. Since the original slice is sharing the underlying array, slice also changed. When there’s no available capacity in the underlying array for a slice, the append function will create a new underlying array, copy the existing values that are being referenced, and assign the new value 1 2 3 4 5 6 7 8 func main() { slice := []int{10,20,30,40} newSlice :=append(slice,60) fmt.Println(slice) fmt.Println(newSlice) } [10 20 30 40] [10 20 30 40 60] By having the option to set the capacity of a new slice to be the same as the length, you can force the first append operation to detach the new slice from the underlying array. Detaching the new slice from its original source array makes it safe to change. newSlice len=1 and capacity=2 1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { slice := []string{&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;, &quot;Banana&quot;, &quot;Grape&quot;} newSlice :=slice[2:3:4] fmt.Println(slice) fmt.Println(newSlice) newSlice =append(newSlice,&quot;mango&quot;) fmt.Println(slice) fmt.Println(newSlice) } [Apple Orange Plum Banana Grape] [Plum] [Apple Orange Plum mango Grape] [Plum mango] newSlice len=1 and capacity=1 1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { slice := []string{&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;, &quot;Banana&quot;, &quot;Grape&quot;} newSlice :=slice[2:3:3] fmt.Println(slice) fmt.Println(newSlice) newSlice =append(newSlice,&quot;mango&quot;) fmt.Println(slice) fmt.Println(newSlice) } [Apple Orange Plum Banana Grape] [Plum] [Apple Orange Plum Banana Grape] [Plum mango] Iterating over slices Go has a special keyword called range that you use in conjunction with the keyword for to iterate over slices. 1 2 3 4 5 6 7 8 //Create a slice of integers. // Contains a length and capacity of 4 elements. slice := []int{10, 20, 30, 40} // Iterate over each element and display each value. for index, value := range slice { fmt.Printf(&quot;Index: %d Value: %d\n&quot;, index, value) } The first value is the index position and the second value is a copy of the value in that index position. It’s important to know that range is making a copy of the value, not returning a reference If you don’t need the index value, you can use the underscore character to discard the value. 1 2 3 4 5 6 7 8 // Create a slice of integers. // Contains a length and capacity of 4 elements. slice := []int{10, 20, 30, 40} // Iterate over each element and display each value. for _, value := range slice { fmt.Printf(&quot;Value: %d\n&quot;, value) } The keyword range will always start iterating over a slice from the beginning. If you need more control iterating over a slice, you can always use a traditional for loop. 1 2 3 4 5 6 7 8 // Create a slice of integers. // Contains a length and capacity of 4 elements. slice := []int{10, 20, 30, 40} // Iterate over each element starting at element 3. for index := 2; index &lt; len(slice); index++ { fmt.Printf(&quot;Index: %d Value: %d\n&quot;, index, slice[index]) } Passing slices between functions Passing a slice between two functions requires nothing more than passing the slice by value.Since the size of a slice(address, Length, Capacity) is small, it’s cheap to copy and pass between functions. The data associated with a slice is contained in the underlying array, there are no problems passing a copy of a slice to any function. Only the slice is being copied, not the underlying array 1 2 3 4 5 6 7 8 9 slice := make([]int, 1e6) // Pass the slice to the function foo. slice = foo(slice) // Function foo accepts a slice of integers and returns the slice back. func foo(slice []int) []int { //code logic return slice } On a 64-bit architecture, a slice requires 24 bytes of memory while passing to functions.The pointer field requires 8 bytes, and the length and capacity fields require 8 bytes respectively Map Map internals and fundamentals A map is a data structure that provides you with an unordered collection of key/value pairs. The strength of a map is its ability to retrieve data quickly based on the key. A key works like an index, pointing to the value you associate with that key. Maps are unordered collections, and there’s no way to predict the order in which the key/value pairs will be returned, this is because a map is implemented using a hash table. Creating and Initializing You can use the builtin function make, or you can use a map literal. Declaring a map var mp map[string]int Declaring and Initializing a map using make mp := make(map[string]int) Delcaring and Initializing a map using literal mp := map[string]string{&quot;Red&quot;: &quot;#da1337&quot;, &quot;Orange&quot;: &quot;#e95a22&quot;} Slices, functions, and struct types that contain slices can’t be used as map keys. dict := map[[]string]int{} // compiler error There’s nothing stopping you from using a slice as a map value. dict := map[int][]string{} Working with maps Assiging values to a map 1 2 3 4 5 // Create an empty map to store colors and their color codes. colors := map[string]string{} // Add the Red color code to the map. colors[&quot;Red&quot;] = &quot;#da1337&quot; Runtime error assigned to a nil map 1 2 3 4 5 6 7 8 // Create a nil map by just declaring the map. var colors map[string]string // Add the Red color code to the map. colors[&quot;Red&quot;] = &quot;#da1337&quot; Runtime Error: panic: runtime error: assignment to entry in nil map Retrieving a value from a map and testing existence. 1 2 3 4 5 6 7 // Retrieve the value for the key &quot;Blue&quot;. value, exists := colors[&quot;Blue&quot;] // Did this key exist? if exists { fmt.Println(value) } Wrong way of checking existence of Key 1 2 3 4 5 6 7 // Retrieve the value for the key &quot;Blue&quot;. value := colors[&quot;Blue&quot;] // Did this key exist? if value != &quot;&quot; { fmt.Println(value) } When you index a map in Go, it will always return a value, even when the key doesn’t exist. In this case, the zero value for the value’s type is returned. Iterating over a map using for range 1 2 3 4 5 6 7 8 9 10 11 // Create a map of colors and color hex codes. colors := map[string]string{ &quot;AliceBlue&quot;: &quot;#f0f8ff&quot;, &quot;Coral&quot;: &quot;#ff7F50&quot;, &quot;DarkGray&quot;: &quot;#a9a9a9&quot;, &quot;ForestGreen&quot;: &quot;#228b22&quot;, } // Display all the colors in the map. for key, value := range colors { fmt.Printf(&quot;Key: %s Value: %s\n&quot;, key, value) } Removing an item from a map delete(colors, &quot;Coral&quot;) Passing maps between functions Passing a map between two functions doesn’t make a copy of the map. you can pass a map to a function and make changes to the map, and the changes will be reflected by all references to the map. ```go func main() { mp :=map[int]int{ 10:1, 20:2, 30:3, 40:4, 50:5, } fmt.Println(mp) removeKey(mp,20) fmt.Println(mp) }" /><meta property="og:description" content="Array Array Internals and fundamentals An array in Go is a fixed-length data type that contains a contiguous block of elements of the same type. Arrays are valuable data structures because the memory is allocated sequentially. Having memory in a contiguous form can help to keep the memory you use stay loaded within CPU caches longer. An array is a value in Go. This means you can use it in an assignment operation. The variable name denotes the entire array and, therefore, an array can be assigned to other arrays of the same type. When an array is initialized in Go, each individual element that belongs to the array is initialized to its zero value. Declaring and Initializing Declare an integer array of five elements var array [5]int Array literals allow you to declare the number of elements you need and specify values for those elements Declaring and Initialize an array using an array literal array := [5]int{10, 20, 30, 40, 50} Declaring and Initialize an array with Go calculating size array := [...]int{10, 20, 30, 40, 50} Declaring an array initializing specific elements array := [5]int{1: 10, 2: 20} Declaring two-dimensional arrays var array [4][2]int Passing arrays between functions Passing an array between functions can be an expensive operation in terms of memory and performance. When your variable is an array, this means the entire array, regardless of its size, is copied and passed to the function. Slice Slice internals and fundamentals Slices are built around the concept of dynamic arrays that can grow and shrink They’re three field data structures that contain the metadata. The three fields are a pointer to the underlying array, the length or the number of elements the slice has access to, and the capacity or the number of elements the slice has available for growth. Remember, if you specify a value inside the [ ] operator, you’re creating an array. If you don’t specify a value, you’re creating a slice. Create an array of three integers. array := [3]int{10, 20, 30} Create a slice of integers with a length and capacity of three. slice := []int{10, 20, 30} Creating and Initializing When you use make, one option you have is to specify the length of the slice. Declaring a slice of strings by length slice := make([]string, 5) Declaring a slice of integers by length and capacity slice := make([]int, 3, 5) Contains a length of 3 and has a capacity of 5 elements. Trying to create a slice with a capacity that’s smaller than the length is not allowed Declaring a slice with a slice literal slice := []string{&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;} NIL and empty slices Declaring an nil slice. var slice []int A nil slice is created by declaring a slice without any initialization. Declaring an empty slice slice := make([]int, 0) slice := []int{} NIL useful when you want to represent a slice that doesn’t exist, such as when an exception occurs in a function that returns a slice. Empty slices are useful when you want to represent an empty collection, such as when a database query returns zero results . Regardless of whether you’re using a nil slice or an empty slice, the built-in functions append, len, and cap work the same. Working with slices Slices are called such because you can slice a portion of the underlying array to create a new slice. 1 2 slice := []int{10, 20, 30, 40, 50} newSlice := slice[1:3] Changes made to the shared section of the underlying array by one slice can be seen by the other slice. Calculating Length and Capacity of Slice For slice[i:j:k] or [2:3:4] Length: j - i or 3 - 2 = 1 Capacity: k - i or 4 - 2 = 2 To use append, you need a source slice and a value that is to be appended. When your append call returns, it provides you a new slice with the changes.The append function will always increase the length of the new slice. 1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { slice := []int{10,20,30,40,50} newSlice := slice[1:3] fmt.Println(slice) fmt.Println(newSlice) newSlice =append(newSlice,60) fmt.Println(slice) fmt.Println(newSlice) } [10 20 30 40 50] [20 30] [10 20 30 60 50] [20 30 60] Because there was available capacity in the underlying array for newSlice, the append operation incorporated the available element into the slice’s length and assigned the value. Since the original slice is sharing the underlying array, slice also changed. When there’s no available capacity in the underlying array for a slice, the append function will create a new underlying array, copy the existing values that are being referenced, and assign the new value 1 2 3 4 5 6 7 8 func main() { slice := []int{10,20,30,40} newSlice :=append(slice,60) fmt.Println(slice) fmt.Println(newSlice) } [10 20 30 40] [10 20 30 40 60] By having the option to set the capacity of a new slice to be the same as the length, you can force the first append operation to detach the new slice from the underlying array. Detaching the new slice from its original source array makes it safe to change. newSlice len=1 and capacity=2 1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { slice := []string{&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;, &quot;Banana&quot;, &quot;Grape&quot;} newSlice :=slice[2:3:4] fmt.Println(slice) fmt.Println(newSlice) newSlice =append(newSlice,&quot;mango&quot;) fmt.Println(slice) fmt.Println(newSlice) } [Apple Orange Plum Banana Grape] [Plum] [Apple Orange Plum mango Grape] [Plum mango] newSlice len=1 and capacity=1 1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { slice := []string{&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;, &quot;Banana&quot;, &quot;Grape&quot;} newSlice :=slice[2:3:3] fmt.Println(slice) fmt.Println(newSlice) newSlice =append(newSlice,&quot;mango&quot;) fmt.Println(slice) fmt.Println(newSlice) } [Apple Orange Plum Banana Grape] [Plum] [Apple Orange Plum Banana Grape] [Plum mango] Iterating over slices Go has a special keyword called range that you use in conjunction with the keyword for to iterate over slices. 1 2 3 4 5 6 7 8 //Create a slice of integers. // Contains a length and capacity of 4 elements. slice := []int{10, 20, 30, 40} // Iterate over each element and display each value. for index, value := range slice { fmt.Printf(&quot;Index: %d Value: %d\n&quot;, index, value) } The first value is the index position and the second value is a copy of the value in that index position. It’s important to know that range is making a copy of the value, not returning a reference If you don’t need the index value, you can use the underscore character to discard the value. 1 2 3 4 5 6 7 8 // Create a slice of integers. // Contains a length and capacity of 4 elements. slice := []int{10, 20, 30, 40} // Iterate over each element and display each value. for _, value := range slice { fmt.Printf(&quot;Value: %d\n&quot;, value) } The keyword range will always start iterating over a slice from the beginning. If you need more control iterating over a slice, you can always use a traditional for loop. 1 2 3 4 5 6 7 8 // Create a slice of integers. // Contains a length and capacity of 4 elements. slice := []int{10, 20, 30, 40} // Iterate over each element starting at element 3. for index := 2; index &lt; len(slice); index++ { fmt.Printf(&quot;Index: %d Value: %d\n&quot;, index, slice[index]) } Passing slices between functions Passing a slice between two functions requires nothing more than passing the slice by value.Since the size of a slice(address, Length, Capacity) is small, it’s cheap to copy and pass between functions. The data associated with a slice is contained in the underlying array, there are no problems passing a copy of a slice to any function. Only the slice is being copied, not the underlying array 1 2 3 4 5 6 7 8 9 slice := make([]int, 1e6) // Pass the slice to the function foo. slice = foo(slice) // Function foo accepts a slice of integers and returns the slice back. func foo(slice []int) []int { //code logic return slice } On a 64-bit architecture, a slice requires 24 bytes of memory while passing to functions.The pointer field requires 8 bytes, and the length and capacity fields require 8 bytes respectively Map Map internals and fundamentals A map is a data structure that provides you with an unordered collection of key/value pairs. The strength of a map is its ability to retrieve data quickly based on the key. A key works like an index, pointing to the value you associate with that key. Maps are unordered collections, and there’s no way to predict the order in which the key/value pairs will be returned, this is because a map is implemented using a hash table. Creating and Initializing You can use the builtin function make, or you can use a map literal. Declaring a map var mp map[string]int Declaring and Initializing a map using make mp := make(map[string]int) Delcaring and Initializing a map using literal mp := map[string]string{&quot;Red&quot;: &quot;#da1337&quot;, &quot;Orange&quot;: &quot;#e95a22&quot;} Slices, functions, and struct types that contain slices can’t be used as map keys. dict := map[[]string]int{} // compiler error There’s nothing stopping you from using a slice as a map value. dict := map[int][]string{} Working with maps Assiging values to a map 1 2 3 4 5 // Create an empty map to store colors and their color codes. colors := map[string]string{} // Add the Red color code to the map. colors[&quot;Red&quot;] = &quot;#da1337&quot; Runtime error assigned to a nil map 1 2 3 4 5 6 7 8 // Create a nil map by just declaring the map. var colors map[string]string // Add the Red color code to the map. colors[&quot;Red&quot;] = &quot;#da1337&quot; Runtime Error: panic: runtime error: assignment to entry in nil map Retrieving a value from a map and testing existence. 1 2 3 4 5 6 7 // Retrieve the value for the key &quot;Blue&quot;. value, exists := colors[&quot;Blue&quot;] // Did this key exist? if exists { fmt.Println(value) } Wrong way of checking existence of Key 1 2 3 4 5 6 7 // Retrieve the value for the key &quot;Blue&quot;. value := colors[&quot;Blue&quot;] // Did this key exist? if value != &quot;&quot; { fmt.Println(value) } When you index a map in Go, it will always return a value, even when the key doesn’t exist. In this case, the zero value for the value’s type is returned. Iterating over a map using for range 1 2 3 4 5 6 7 8 9 10 11 // Create a map of colors and color hex codes. colors := map[string]string{ &quot;AliceBlue&quot;: &quot;#f0f8ff&quot;, &quot;Coral&quot;: &quot;#ff7F50&quot;, &quot;DarkGray&quot;: &quot;#a9a9a9&quot;, &quot;ForestGreen&quot;: &quot;#228b22&quot;, } // Display all the colors in the map. for key, value := range colors { fmt.Printf(&quot;Key: %s Value: %s\n&quot;, key, value) } Removing an item from a map delete(colors, &quot;Coral&quot;) Passing maps between functions Passing a map between two functions doesn’t make a copy of the map. you can pass a map to a function and make changes to the map, and the changes will be reflected by all references to the map. ```go func main() { mp :=map[int]int{ 10:1, 20:2, 30:3, 40:4, 50:5, } fmt.Println(mp) removeKey(mp,20) fmt.Println(mp) }" /><link rel="canonical" href="https://mukeshpilaniya.github.io/posts/Array-Slice-And-Map-in-Golang/" /><meta property="og:url" content="https://mukeshpilaniya.github.io/posts/Array-Slice-And-Map-in-Golang/" /><meta property="og:site_name" content="pilaniya@home:~$" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-08-10T00:00:00+05:30" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Array Slice And Map In Golang" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-08-17T23:12:04+05:30","datePublished":"2022-08-10T00:00:00+05:30","description":"Array Array Internals and fundamentals An array in Go is a fixed-length data type that contains a contiguous block of elements of the same type. Arrays are valuable data structures because the memory is allocated sequentially. Having memory in a contiguous form can help to keep the memory you use stay loaded within CPU caches longer. An array is a value in Go. This means you can use it in an assignment operation. The variable name denotes the entire array and, therefore, an array can be assigned to other arrays of the same type. When an array is initialized in Go, each individual element that belongs to the array is initialized to its zero value. Declaring and Initializing Declare an integer array of five elements var array [5]int Array literals allow you to declare the number of elements you need and specify values for those elements Declaring and Initialize an array using an array literal array := [5]int{10, 20, 30, 40, 50} Declaring and Initialize an array with Go calculating size array := [...]int{10, 20, 30, 40, 50} Declaring an array initializing specific elements array := [5]int{1: 10, 2: 20} Declaring two-dimensional arrays var array [4][2]int Passing arrays between functions Passing an array between functions can be an expensive operation in terms of memory and performance. When your variable is an array, this means the entire array, regardless of its size, is copied and passed to the function. Slice Slice internals and fundamentals Slices are built around the concept of dynamic arrays that can grow and shrink They’re three field data structures that contain the metadata. The three fields are a pointer to the underlying array, the length or the number of elements the slice has access to, and the capacity or the number of elements the slice has available for growth. Remember, if you specify a value inside the [ ] operator, you’re creating an array. If you don’t specify a value, you’re creating a slice. Create an array of three integers. array := [3]int{10, 20, 30} Create a slice of integers with a length and capacity of three. slice := []int{10, 20, 30} Creating and Initializing When you use make, one option you have is to specify the length of the slice. Declaring a slice of strings by length slice := make([]string, 5) Declaring a slice of integers by length and capacity slice := make([]int, 3, 5) Contains a length of 3 and has a capacity of 5 elements. Trying to create a slice with a capacity that’s smaller than the length is not allowed Declaring a slice with a slice literal slice := []string{&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;} NIL and empty slices Declaring an nil slice. var slice []int A nil slice is created by declaring a slice without any initialization. Declaring an empty slice slice := make([]int, 0) slice := []int{} NIL useful when you want to represent a slice that doesn’t exist, such as when an exception occurs in a function that returns a slice. Empty slices are useful when you want to represent an empty collection, such as when a database query returns zero results . Regardless of whether you’re using a nil slice or an empty slice, the built-in functions append, len, and cap work the same. Working with slices Slices are called such because you can slice a portion of the underlying array to create a new slice. 1 2 slice := []int{10, 20, 30, 40, 50} newSlice := slice[1:3] Changes made to the shared section of the underlying array by one slice can be seen by the other slice. Calculating Length and Capacity of Slice For slice[i:j:k] or [2:3:4] Length: j - i or 3 - 2 = 1 Capacity: k - i or 4 - 2 = 2 To use append, you need a source slice and a value that is to be appended. When your append call returns, it provides you a new slice with the changes.The append function will always increase the length of the new slice. 1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { slice := []int{10,20,30,40,50} newSlice := slice[1:3] fmt.Println(slice) fmt.Println(newSlice) newSlice =append(newSlice,60) fmt.Println(slice) fmt.Println(newSlice) } [10 20 30 40 50] [20 30] [10 20 30 60 50] [20 30 60] Because there was available capacity in the underlying array for newSlice, the append operation incorporated the available element into the slice’s length and assigned the value. Since the original slice is sharing the underlying array, slice also changed. When there’s no available capacity in the underlying array for a slice, the append function will create a new underlying array, copy the existing values that are being referenced, and assign the new value 1 2 3 4 5 6 7 8 func main() { slice := []int{10,20,30,40} newSlice :=append(slice,60) fmt.Println(slice) fmt.Println(newSlice) } [10 20 30 40] [10 20 30 40 60] By having the option to set the capacity of a new slice to be the same as the length, you can force the first append operation to detach the new slice from the underlying array. Detaching the new slice from its original source array makes it safe to change. newSlice len=1 and capacity=2 1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { slice := []string{&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;, &quot;Banana&quot;, &quot;Grape&quot;} newSlice :=slice[2:3:4] fmt.Println(slice) fmt.Println(newSlice) newSlice =append(newSlice,&quot;mango&quot;) fmt.Println(slice) fmt.Println(newSlice) } [Apple Orange Plum Banana Grape] [Plum] [Apple Orange Plum mango Grape] [Plum mango] newSlice len=1 and capacity=1 1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { slice := []string{&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;, &quot;Banana&quot;, &quot;Grape&quot;} newSlice :=slice[2:3:3] fmt.Println(slice) fmt.Println(newSlice) newSlice =append(newSlice,&quot;mango&quot;) fmt.Println(slice) fmt.Println(newSlice) } [Apple Orange Plum Banana Grape] [Plum] [Apple Orange Plum Banana Grape] [Plum mango] Iterating over slices Go has a special keyword called range that you use in conjunction with the keyword for to iterate over slices. 1 2 3 4 5 6 7 8 //Create a slice of integers. // Contains a length and capacity of 4 elements. slice := []int{10, 20, 30, 40} // Iterate over each element and display each value. for index, value := range slice { fmt.Printf(&quot;Index: %d Value: %d\\n&quot;, index, value) } The first value is the index position and the second value is a copy of the value in that index position. It’s important to know that range is making a copy of the value, not returning a reference If you don’t need the index value, you can use the underscore character to discard the value. 1 2 3 4 5 6 7 8 // Create a slice of integers. // Contains a length and capacity of 4 elements. slice := []int{10, 20, 30, 40} // Iterate over each element and display each value. for _, value := range slice { fmt.Printf(&quot;Value: %d\\n&quot;, value) } The keyword range will always start iterating over a slice from the beginning. If you need more control iterating over a slice, you can always use a traditional for loop. 1 2 3 4 5 6 7 8 // Create a slice of integers. // Contains a length and capacity of 4 elements. slice := []int{10, 20, 30, 40} // Iterate over each element starting at element 3. for index := 2; index &lt; len(slice); index++ { fmt.Printf(&quot;Index: %d Value: %d\\n&quot;, index, slice[index]) } Passing slices between functions Passing a slice between two functions requires nothing more than passing the slice by value.Since the size of a slice(address, Length, Capacity) is small, it’s cheap to copy and pass between functions. The data associated with a slice is contained in the underlying array, there are no problems passing a copy of a slice to any function. Only the slice is being copied, not the underlying array 1 2 3 4 5 6 7 8 9 slice := make([]int, 1e6) // Pass the slice to the function foo. slice = foo(slice) // Function foo accepts a slice of integers and returns the slice back. func foo(slice []int) []int { //code logic return slice } On a 64-bit architecture, a slice requires 24 bytes of memory while passing to functions.The pointer field requires 8 bytes, and the length and capacity fields require 8 bytes respectively Map Map internals and fundamentals A map is a data structure that provides you with an unordered collection of key/value pairs. The strength of a map is its ability to retrieve data quickly based on the key. A key works like an index, pointing to the value you associate with that key. Maps are unordered collections, and there’s no way to predict the order in which the key/value pairs will be returned, this is because a map is implemented using a hash table. Creating and Initializing You can use the builtin function make, or you can use a map literal. Declaring a map var mp map[string]int Declaring and Initializing a map using make mp := make(map[string]int) Delcaring and Initializing a map using literal mp := map[string]string{&quot;Red&quot;: &quot;#da1337&quot;, &quot;Orange&quot;: &quot;#e95a22&quot;} Slices, functions, and struct types that contain slices can’t be used as map keys. dict := map[[]string]int{} // compiler error There’s nothing stopping you from using a slice as a map value. dict := map[int][]string{} Working with maps Assiging values to a map 1 2 3 4 5 // Create an empty map to store colors and their color codes. colors := map[string]string{} // Add the Red color code to the map. colors[&quot;Red&quot;] = &quot;#da1337&quot; Runtime error assigned to a nil map 1 2 3 4 5 6 7 8 // Create a nil map by just declaring the map. var colors map[string]string // Add the Red color code to the map. colors[&quot;Red&quot;] = &quot;#da1337&quot; Runtime Error: panic: runtime error: assignment to entry in nil map Retrieving a value from a map and testing existence. 1 2 3 4 5 6 7 // Retrieve the value for the key &quot;Blue&quot;. value, exists := colors[&quot;Blue&quot;] // Did this key exist? if exists { fmt.Println(value) } Wrong way of checking existence of Key 1 2 3 4 5 6 7 // Retrieve the value for the key &quot;Blue&quot;. value := colors[&quot;Blue&quot;] // Did this key exist? if value != &quot;&quot; { fmt.Println(value) } When you index a map in Go, it will always return a value, even when the key doesn’t exist. In this case, the zero value for the value’s type is returned. Iterating over a map using for range 1 2 3 4 5 6 7 8 9 10 11 // Create a map of colors and color hex codes. colors := map[string]string{ &quot;AliceBlue&quot;: &quot;#f0f8ff&quot;, &quot;Coral&quot;: &quot;#ff7F50&quot;, &quot;DarkGray&quot;: &quot;#a9a9a9&quot;, &quot;ForestGreen&quot;: &quot;#228b22&quot;, } // Display all the colors in the map. for key, value := range colors { fmt.Printf(&quot;Key: %s Value: %s\\n&quot;, key, value) } Removing an item from a map delete(colors, &quot;Coral&quot;) Passing maps between functions Passing a map between two functions doesn’t make a copy of the map. you can pass a map to a function and make changes to the map, and the changes will be reflected by all references to the map. ```go func main() { mp :=map[int]int{ 10:1, 20:2, 30:3, 40:4, 50:5, } fmt.Println(mp) removeKey(mp,20) fmt.Println(mp) }","headline":"Array Slice And Map In Golang","mainEntityOfPage":{"@type":"WebPage","@id":"https://mukeshpilaniya.github.io/posts/Array-Slice-And-Map-in-Golang/"},"url":"https://mukeshpilaniya.github.io/posts/Array-Slice-And-Map-in-Golang/"}</script><title>Array Slice And Map In Golang | pilaniya@home:~$</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="pilaniya@home:~$"><meta name="application-name" content="pilaniya@home:~$"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/12998935?s=400&u=0874b267fd66e5fea11f5181868ddae3c58e0a93&v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">pilaniya@home:~$</a></div><div class="site-subtitle font-italic">Learn.unlearn.relearn</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/mukeshpilaniya" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['pilaniyamukesh0','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Array Slice And Map In Golang</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Array Slice And Map In Golang</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1660069800" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Aug 10, 2022 </em> </span> <span> Updated <em class="" data-ts="1660758124" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Aug 17, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://www.linkedin.com/in/mukeshpilaniya">Mukesh Pilaniya</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2065 words"> <em>11 min</em> read</span></div></div></div><div class="post-content"><ol><li><h3 id="array"><span class="mr-2">Array</span><a href="#array" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Array Internals and fundamentals<ul><li>An array in Go is a fixed-length data type that contains a contiguous block of elements of the same type.<li>Arrays are valuable data structures because the memory is allocated sequentially.<li>Having memory in a contiguous form can help to keep the memory you use stay loaded within CPU caches longer.<li>An array is a value in Go. This means you can use it in an assignment operation. The variable name denotes the entire array and, therefore, an array can be assigned to other arrays of the same type.<li>When an array is initialized in Go, each individual element that belongs to the array is initialized to its zero value. <img data-src="https://github.com/mukeshpilaniya/blog/blob/master/_posts/Golang/images/array.png?raw=true" alt="array" data-proofer-ignore></ul><li>Declaring and Initializing<ul><li>Declare an integer array of five elements<br /> <code class="language-plaintext highlighter-rouge">var array [5]int</code><li>Array literals allow you to declare the number of elements you need and specify values for those elements<li>Declaring and Initialize an array using an array literal<br /> <code class="language-plaintext highlighter-rouge">array := [5]int{10, 20, 30, 40, 50}</code><li>Declaring and Initialize an array with Go calculating size<br /> <code class="language-plaintext highlighter-rouge">array := [...]int{10, 20, 30, 40, 50}</code><li>Declaring an array initializing specific elements<br /> <code class="language-plaintext highlighter-rouge">array := [5]int{1: 10, 2: 20}</code><li>Declaring two-dimensional arrays<br /> <code class="language-plaintext highlighter-rouge">var array [4][2]int</code></ul><li>Passing arrays between functions<ul><li>Passing an array between functions can be an expensive operation in terms of memory and performance.<li>When your variable is an array, this means the entire array, regardless of its size, is copied and passed to the function.</ul></ul><li><h3 id="slice"><span class="mr-2">Slice</span><a href="#slice" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Slice internals and fundamentals<ul><li>Slices are built around the concept of dynamic arrays that can grow and shrink<li>They’re three field data structures that contain the metadata. The three fields are a pointer to the underlying array, the length or the number of elements the slice has access to, and the capacity or the number of elements the slice has available for growth.<li>Remember, if you specify a value inside the [ ] operator, you’re creating an array. If you don’t specify a value, you’re creating a slice.<ul><li>Create an array of three integers.<br /> <code class="language-plaintext highlighter-rouge">array := [3]int{10, 20, 30}</code><li>Create a slice of integers with a length and capacity of three.<br /> <code class="language-plaintext highlighter-rouge">slice := []int{10, 20, 30}</code> <img data-src="https://github.com/mukeshpilaniya/blog/blob/master/_posts/Golang/images/slice.png?raw=true" alt="Slice" data-proofer-ignore></ul></ul><li>Creating and Initializing<ul><li>When you use make, one option you have is to specify the length of the slice.<li>Declaring a slice of strings by length<br /> <code class="language-plaintext highlighter-rouge">slice := make([]string, 5)</code><li>Declaring a slice of integers by length and capacity<br /> <code class="language-plaintext highlighter-rouge">slice := make([]int, 3, 5)</code><br /> Contains a length of 3 and has a capacity of 5 elements. Trying to create a slice with a capacity that’s smaller than the length is not allowed<li>Declaring a slice with a slice literal<br /> <code class="language-plaintext highlighter-rouge">slice := []string{"Red", "Blue", "Green", "Yellow", "Pink"}</code></ul><li>NIL and empty slices<ul><li>Declaring an nil slice.<br /> <code class="language-plaintext highlighter-rouge">var slice []int</code><br /> A nil slice is created by declaring a slice without any initialization. <img data-src="https://github.com/mukeshpilaniya/blog/blob/master/_posts/Golang/images/nil_slice.png?raw=true" alt="Nil Slice " data-proofer-ignore><li>Declaring an empty slice<br /> <code class="language-plaintext highlighter-rouge">slice := make([]int, 0)</code><br /> <code class="language-plaintext highlighter-rouge">slice := []int{}</code><br /> <img data-src="https://github.com/mukeshpilaniya/blog/blob/master/_posts/Golang/images/empty_slice.png?raw=true" alt="empty Slice" data-proofer-ignore><li>NIL useful when you want to represent a slice that doesn’t exist, such as when an exception occurs in a function that returns a slice.<li>Empty slices are useful when you want to represent an empty collection, such as when a database query returns zero results .<li>Regardless of whether you’re using a nil slice or an empty slice, the built-in functions append, len, and cap work the same.</ul><li>Working with slices<ul><li>Slices are called such because you can slice a portion of the underlying array to create a new slice.<div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>  slice := []int{10, 20, 30, 40, 50}
  newSlice := slice[1:3]
</pre></table></code></div></div><p>Changes made to the shared section of the underlying array by one slice can be seen by the other slice. <img data-src="https://github.com/mukeshpilaniya/blog/blob/master/_posts/Golang/images/working_with_slice.png?raw=true" alt="newSlice" data-proofer-ignore></p><li>Calculating Length and Capacity of Slice<br /> For slice[i:j:k] or [2:3:4]<br /> Length: j - i or 3 - 2 = 1<br /> Capacity: k - i or 4 - 2 = 2<li>To use append, you need a source slice and a value that is to be appended. When your append call returns, it provides you a new slice with the changes.The append function will always increase the length of the new slice.<div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>  <span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">10</span><span class="p">,</span><span class="m">20</span><span class="p">,</span><span class="m">30</span><span class="p">,</span><span class="m">40</span><span class="p">,</span><span class="m">50</span><span class="p">}</span>
      <span class="n">newSlice</span> <span class="o">:=</span> <span class="n">slice</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">]</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">slice</span><span class="p">)</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">newSlice</span><span class="p">)</span>
      <span class="n">newSlice</span> <span class="o">=</span><span class="nb">append</span><span class="p">(</span><span class="n">newSlice</span><span class="p">,</span><span class="m">60</span><span class="p">)</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">slice</span><span class="p">)</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">newSlice</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="p">[</span><span class="m">10</span> <span class="m">20</span> <span class="m">30</span> <span class="m">40</span> <span class="m">50</span><span class="p">]</span>
  <span class="p">[</span><span class="m">20</span> <span class="m">30</span><span class="p">]</span>
  <span class="p">[</span><span class="m">10</span> <span class="m">20</span> <span class="m">30</span> <span class="m">60</span> <span class="m">50</span><span class="p">]</span>
  <span class="p">[</span><span class="m">20</span> <span class="m">30</span> <span class="m">60</span><span class="p">]</span>
</pre></table></code></div></div><p>Because there was available capacity in the underlying array for newSlice, the append operation incorporated the available element into the slice’s length and assigned the value. Since the original slice is sharing the underlying array, slice also changed. <img data-src="https://github.com/mukeshpilaniya/blog/blob/master/_posts/Golang/images/slice_changes.png?raw=true" alt="Slice Changed" data-proofer-ignore></p><li>When there’s no available capacity in the underlying array for a slice, the append function will create a new underlying array, copy the existing values that are being referenced, and assign the new value<div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>  <span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">10</span><span class="p">,</span><span class="m">20</span><span class="p">,</span><span class="m">30</span><span class="p">,</span><span class="m">40</span><span class="p">}</span>
      <span class="n">newSlice</span> <span class="o">:=</span><span class="nb">append</span><span class="p">(</span><span class="n">slice</span><span class="p">,</span><span class="m">60</span><span class="p">)</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">slice</span><span class="p">)</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">newSlice</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="p">[</span><span class="m">10</span> <span class="m">20</span> <span class="m">30</span> <span class="m">40</span><span class="p">]</span>
  <span class="p">[</span><span class="m">10</span> <span class="m">20</span> <span class="m">30</span> <span class="m">40</span> <span class="m">60</span><span class="p">]</span>
</pre></table></code></div></div><p><img data-src="https://github.com/mukeshpilaniya/blog/blob/master/_posts/Golang/images/slice_not_changed.png?raw=true" alt="Slice not Changed" data-proofer-ignore></p><li>By having the option to set the capacity of a new slice to be the same as the length, you can force the first append operation to detach the new slice from the underlying array. Detaching the new slice from its original source array makes it safe to change.<ul><li>newSlice len=1 and capacity=2<div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>  <span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"Apple"</span><span class="p">,</span> <span class="s">"Orange"</span><span class="p">,</span> <span class="s">"Plum"</span><span class="p">,</span> <span class="s">"Banana"</span><span class="p">,</span> <span class="s">"Grape"</span><span class="p">}</span>
      <span class="n">newSlice</span> <span class="o">:=</span><span class="n">slice</span><span class="p">[</span><span class="m">2</span><span class="o">:</span><span class="m">3</span><span class="o">:</span><span class="m">4</span><span class="p">]</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">slice</span><span class="p">)</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">newSlice</span><span class="p">)</span>
      <span class="n">newSlice</span> <span class="o">=</span><span class="nb">append</span><span class="p">(</span><span class="n">newSlice</span><span class="p">,</span><span class="s">"mango"</span><span class="p">)</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">slice</span><span class="p">)</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">newSlice</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="p">[</span><span class="n">Apple</span> <span class="n">Orange</span> <span class="n">Plum</span> <span class="n">Banana</span> <span class="n">Grape</span><span class="p">]</span>
  <span class="p">[</span><span class="n">Plum</span><span class="p">]</span>
  <span class="p">[</span><span class="n">Apple</span> <span class="n">Orange</span> <span class="n">Plum</span> <span class="n">mango</span> <span class="n">Grape</span><span class="p">]</span>
  <span class="p">[</span><span class="n">Plum</span> <span class="n">mango</span><span class="p">]</span>
</pre></table></code></div></div><li>newSlice len=1 and capacity=1<div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>  <span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"Apple"</span><span class="p">,</span> <span class="s">"Orange"</span><span class="p">,</span> <span class="s">"Plum"</span><span class="p">,</span> <span class="s">"Banana"</span><span class="p">,</span> <span class="s">"Grape"</span><span class="p">}</span>
      <span class="n">newSlice</span> <span class="o">:=</span><span class="n">slice</span><span class="p">[</span><span class="m">2</span><span class="o">:</span><span class="m">3</span><span class="o">:</span><span class="m">3</span><span class="p">]</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">slice</span><span class="p">)</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">newSlice</span><span class="p">)</span>
      <span class="n">newSlice</span> <span class="o">=</span><span class="nb">append</span><span class="p">(</span><span class="n">newSlice</span><span class="p">,</span><span class="s">"mango"</span><span class="p">)</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">slice</span><span class="p">)</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">newSlice</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="p">[</span><span class="n">Apple</span> <span class="n">Orange</span> <span class="n">Plum</span> <span class="n">Banana</span> <span class="n">Grape</span><span class="p">]</span>
  <span class="p">[</span><span class="n">Plum</span><span class="p">]</span>
  <span class="p">[</span><span class="n">Apple</span> <span class="n">Orange</span> <span class="n">Plum</span> <span class="n">Banana</span> <span class="n">Grape</span><span class="p">]</span>
  <span class="p">[</span><span class="n">Plum</span> <span class="n">mango</span><span class="p">]</span>
</pre></table></code></div></div></ul></ul><li>Iterating over slices<ul><li>Go has a special keyword called range that you use in conjunction with the keyword for to iterate over slices.<div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>  <span class="c">//Create a slice of integers.</span>
  <span class="c">// Contains a length and capacity of 4 elements.</span>
  <span class="n">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">10</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">30</span><span class="p">,</span> <span class="m">40</span><span class="p">}</span>
            
  <span class="c">// Iterate over each element and display each value.</span>
  <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">slice</span> <span class="p">{</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Index: %d Value: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
  <span class="p">}</span>
</pre></table></code></div></div><li>The first value is the index position and the second value is a copy of the value in that index position. It’s important to know that range is making a copy of the value, not returning a reference <img data-src="https://github.com/mukeshpilaniya/blog/blob/master/_posts/Golang/images/range_value_copy.png?raw=true" alt="range loop" data-proofer-ignore><li>If you don’t need the index value, you can use the underscore character to discard the value.<div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>  <span class="c">// Create a slice of integers.</span>
  <span class="c">// Contains a length and capacity of 4 elements.</span>
  <span class="n">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">10</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">30</span><span class="p">,</span> <span class="m">40</span><span class="p">}</span>
            
  <span class="c">// Iterate over each element and display each value.</span>
  <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">slice</span> <span class="p">{</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Value: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
  <span class="p">}</span>
</pre></table></code></div></div><li>The keyword range will always start iterating over a slice from the beginning. If you need more control iterating over a slice, you can always use a traditional for loop.<div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>  <span class="c">// Create a slice of integers.</span>
  <span class="c">// Contains a length and capacity of 4 elements.</span>
  <span class="n">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">10</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">30</span><span class="p">,</span> <span class="m">40</span><span class="p">}</span>
            
  <span class="c">// Iterate over each element starting at element 3.</span>
  <span class="k">for</span> <span class="n">index</span> <span class="o">:=</span> <span class="m">2</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">slice</span><span class="p">);</span> <span class="n">index</span><span class="o">++</span> <span class="p">{</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Index: %d Value: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">slice</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
  <span class="p">}</span>
</pre></table></code></div></div></ul><li>Passing slices between functions<ul><li>Passing a slice between two functions requires nothing more than passing the slice by value.Since the size of a slice(address, Length, Capacity) is small, it’s cheap to copy and pass between functions.<li>The data associated with a slice is contained in the underlying array, there are no problems passing a copy of a slice to any function. Only the slice is being copied, not the underlying array<div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>  <span class="n">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="m">1e6</span><span class="p">)</span>
  <span class="c">// Pass the slice to the function foo.</span>
  <span class="n">slice</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">slice</span><span class="p">)</span>
            
  <span class="c">// Function foo accepts a slice of integers and returns the slice back.</span>
  <span class="k">func</span> <span class="n">foo</span><span class="p">(</span><span class="n">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
      <span class="c">//code logic </span>
      <span class="k">return</span> <span class="n">slice</span>
  <span class="p">}</span>
</pre></table></code></div></div><p><img data-src="https://github.com/mukeshpilaniya/blog/blob/master/_posts/Golang/images/slice_pass_func.png?raw=true" alt="Slice passing to func" data-proofer-ignore></p><li>On a 64-bit architecture, a slice requires 24 bytes of memory while passing to functions.The pointer field requires 8 bytes, and the length and capacity fields require 8 bytes respectively</ul></ul><li><h3 id="map"><span class="mr-2">Map</span><a href="#map" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Map internals and fundamentals<ul><li>A map is a data structure that provides you with an unordered collection of key/value pairs.<li>The strength of a map is its ability to retrieve data quickly based on the key. A key works like an index, pointing to the value you associate with that key.<li>Maps are unordered collections, and there’s no way to predict the order in which the key/value pairs will be returned, this is because a map is implemented using a hash table.</ul><li>Creating and Initializing<ul><li>You can use the builtin function make, or you can use a map literal.<li>Declaring a map<br /> <code class="language-plaintext highlighter-rouge">var mp map[string]int</code><li>Declaring and Initializing a map using make<br /> <code class="language-plaintext highlighter-rouge">mp := make(map[string]int)</code><li>Delcaring and Initializing a map using literal<br /> <code class="language-plaintext highlighter-rouge">mp := map[string]string{"Red": "#da1337", "Orange": "#e95a22"}</code><li>Slices, functions, and struct types that contain slices can’t be used as map keys. <br /> <code class="language-plaintext highlighter-rouge">dict := map[[]string]int{}</code> // compiler error<li>There’s nothing stopping you from using a slice as a map value.<br /> <code class="language-plaintext highlighter-rouge">dict := map[int][]string{}</code></ul><li>Working with maps<ul><li>Assiging values to a map<div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>  <span class="c">// Create an empty map to store colors and their color codes.</span>
  <span class="n">colors</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{}</span>
            
  <span class="c">// Add the Red color code to the map.</span>
  <span class="n">colors</span><span class="p">[</span><span class="s">"Red"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"#da1337"</span>
</pre></table></code></div></div><li>Runtime error assigned to a nil map<div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>  <span class="c">// Create a nil map by just declaring the map.</span>
  <span class="k">var</span> <span class="n">colors</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
            
  <span class="c">// Add the Red color code to the map.</span>
  <span class="n">colors</span><span class="p">[</span><span class="s">"Red"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"#da1337"</span>
            
  <span class="n">Runtime</span> <span class="n">Error</span><span class="o">:</span>
  <span class="nb">panic</span><span class="o">:</span> <span class="n">runtime</span> <span class="kt">error</span><span class="o">:</span> <span class="n">assignment</span> <span class="n">to</span> <span class="n">entry</span> <span class="n">in</span> <span class="no">nil</span> <span class="k">map</span>
</pre></table></code></div></div><li>Retrieving a value from a map and testing existence.<div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>  <span class="c">// Retrieve the value for the key "Blue".</span>
  <span class="n">value</span><span class="p">,</span> <span class="n">exists</span> <span class="o">:=</span> <span class="n">colors</span><span class="p">[</span><span class="s">"Blue"</span><span class="p">]</span>
            
  <span class="c">// Did this key exist?</span>
  <span class="k">if</span> <span class="n">exists</span> <span class="p">{</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
  <span class="p">}</span>
</pre></table></code></div></div><li><strong>Wrong way of checking existence of Key</strong><div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>  <span class="c">// Retrieve the value for the key "Blue".</span>
  <span class="n">value</span> <span class="o">:=</span> <span class="n">colors</span><span class="p">[</span><span class="s">"Blue"</span><span class="p">]</span>
            
  <span class="c">// Did this key exist?</span>
  <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="s">""</span> <span class="p">{</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
  <span class="p">}</span>
</pre></table></code></div></div><p>When you index a map in Go, it will always return a value, even when the key doesn’t exist. In this case, the zero value for the value’s type is returned.</p><li>Iterating over a map using for range<div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>  <span class="c">// Create a map of colors and color hex codes.</span>
      <span class="n">colors</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
      <span class="s">"AliceBlue"</span><span class="o">:</span> <span class="s">"#f0f8ff"</span><span class="p">,</span>
      <span class="s">"Coral"</span><span class="o">:</span> <span class="s">"#ff7F50"</span><span class="p">,</span>
      <span class="s">"DarkGray"</span><span class="o">:</span> <span class="s">"#a9a9a9"</span><span class="p">,</span>
      <span class="s">"ForestGreen"</span><span class="o">:</span> <span class="s">"#228b22"</span><span class="p">,</span>
  <span class="p">}</span>
  <span class="c">// Display all the colors in the map.</span>
  <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">colors</span> <span class="p">{</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Key: %s Value: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
  <span class="p">}</span>
</pre></table></code></div></div><li>Removing an item from a map<br /> <code class="language-plaintext highlighter-rouge">delete(colors, "Coral")</code></ul><li>Passing maps between functions<ul><li>Passing a map between two functions doesn’t make a copy of the map.<li>you can pass a map to a function and make changes to the map, and the changes will be reflected by all references to the map.<div class="language-go highlighter-rouge"><div class="code-header"> <span data-label-text="Go"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre>  <span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">mp</span> <span class="o">:=</span><span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
          <span class="m">10</span><span class="o">:</span><span class="m">1</span><span class="p">,</span>
          <span class="m">20</span><span class="o">:</span><span class="m">2</span><span class="p">,</span>
          <span class="m">30</span><span class="o">:</span><span class="m">3</span><span class="p">,</span>
          <span class="m">40</span><span class="o">:</span><span class="m">4</span><span class="p">,</span>
          <span class="m">50</span><span class="o">:</span><span class="m">5</span><span class="p">,</span>
      <span class="p">}</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
      <span class="n">removeKey</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span><span class="m">20</span><span class="p">)</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">func</span> <span class="n">removeKey</span><span class="p">(</span><span class="n">mp</span> <span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="n">key</span> <span class="kt">int</span><span class="p">){</span>
      <span class="nb">delete</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span><span class="n">key</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="n">output</span><span class="o">:-</span>
  <span class="k">map</span><span class="p">[</span><span class="m">10</span><span class="o">:</span><span class="m">1</span> <span class="m">20</span><span class="o">:</span><span class="m">2</span> <span class="m">30</span><span class="o">:</span><span class="m">3</span> <span class="m">40</span><span class="o">:</span><span class="m">4</span> <span class="m">50</span><span class="o">:</span><span class="m">5</span><span class="p">]</span>
  <span class="k">map</span><span class="p">[</span><span class="m">10</span><span class="o">:</span><span class="m">1</span> <span class="m">30</span><span class="o">:</span><span class="m">3</span> <span class="m">40</span><span class="o">:</span><span class="m">4</span> <span class="m">50</span><span class="o">:</span><span class="m">5</span><span class="p">]</span>
</pre></table></code></div></div></ul></ul><li><h3 id="summary"><span class="mr-2">Summary</span><a href="#summary" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Arrays are the building blocks for both slices and maps.<li>Slices are the idiomatic way in Go you work with collections of data. Maps are the way you work with key/value pairs of data.<li>The built-in function make allows you to create slices and maps with initial length and capacity. Slice and map literals can be used as well and support setting initial values for use.<li>Slices have a capacity restriction, but can be extended using the built-in function append.<li>Maps don’t have a capacity or any restriction on growth.<li>The built-in function len can be used to retrieve the length of a slice or map.<li>The built-in function cap only works on slices.<li>Through the use of composition, you can create multidimensional arrays and slices. You can also create maps with values that are slices and other maps. A slice can’t be used as a map key.<li>Passing a slice or map to a function is cheap and doesn’t make a copy of the underlying data structure.</ul></ol></div><div class="post-tail-wrapper text-muted"><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Array+Slice+And+Map+In+Golang+-+pilaniya%40home%3A~%24&url=https%3A%2F%2Fmukeshpilaniya.github.io%2Fposts%2FArray-Slice-And-Map-in-Golang%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Array+Slice+And+Map+In+Golang+-+pilaniya%40home%3A~%24&u=https%3A%2F%2Fmukeshpilaniya.github.io%2Fposts%2FArray-Slice-And-Map-in-Golang%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fmukeshpilaniya.github.io%2Fposts%2FArray-Slice-And-Map-in-Golang%2F&text=Array+Slice+And+Map+In+Golang+-+pilaniya%40home%3A~%24" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Go-Schedular/">Go Schedular</a><li><a href="/posts/Solving-modern-programming-challenges-with-Go/">Solving Modern Programming Challenges With Go</a><li><a href="/posts/Classroom-Management-System/">Classroom Management System</a><li><a href="/posts/Calculator-With-DevOps-Tool-Chain/">Calculator With Devops Tool Chain</a><li><a href="/posts/CP-competitive-programming-time-complexity/">Cp Competitive programming time Complexity</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/hibernate/">hibernate</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/jenkins/">jenkins</a> <a class="post-tag" href="/tags/api/">api</a> <a class="post-tag" href="/tags/cp/">cp</a> <a class="post-tag" href="/tags/devops/">devops</a> <a class="post-tag" href="/tags/elk/">elk</a> <a class="post-tag" href="/tags/go/">go</a> <a class="post-tag" href="/tags/golang/">golang</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Go-Schedular/"><div class="card-body"> <em class="small" data-ts="1661279400" data-df="ll" > Aug 24, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Go Schedular</h3><div class="text-muted small"><p> Process Process contains common resources that may be allocated by any process. These resources include but are not limited to a memory address space, handles to files, devices, and threads. ...</p></div></div></a></div><div class="card"> <a href="/posts/Solving-modern-programming-challenges-with-Go/"><div class="card-body"> <em class="small" data-ts="1660674600" data-df="ll" > Aug 17, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Solving Modern Programming Challenges With Go</h3><div class="text-muted small"><p> Development speed Consequently, many Go applications compile in under a second. The entire Go source tree compiles in under 20 seconds on modern hardware. Writing applicat...</p></div></div></a></div><div class="card"> <a href="/posts/Auth/"><div class="card-body"> <em class="small" data-ts="1643999400" data-df="ll" > Feb 5, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Authentication Service</h3><div class="text-muted small"><p> DockerHub Profile: https://hub.docker.com/repository/docker/pilaniya1337/authservice GitHub Profile:https://github.com/mukeshpilaniya/auth MakeFile Start the application make up ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Auth/" class="btn btn-outline-primary" prompt="Older"><p>Authentication Service</p></a> <a href="/posts/Solving-modern-programming-challenges-with-Go/" class="btn btn-outline-primary" prompt="Newer"><p>Solving Modern Programming Challenges With Go</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://www.linkedin.com/in/mukeshpilaniya">Mukesh Pilaniya</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/hibernate/">hibernate</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/jenkins/">jenkins</a> <a class="post-tag" href="/tags/api/">api</a> <a class="post-tag" href="/tags/cp/">cp</a> <a class="post-tag" href="/tags/devops/">devops</a> <a class="post-tag" href="/tags/elk/">elk</a> <a class="post-tag" href="/tags/go/">go</a> <a class="post-tag" href="/tags/golang/">golang</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-HJFWMSHT9C"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-HJFWMSHT9C'); }); </script>
